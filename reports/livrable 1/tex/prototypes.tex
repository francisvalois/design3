%!TEX root = ../rapport.tex
%!TEX encoding = UTF-8 Unicode

% Chapitres "Introduction"

% modifié par Francis Valois, Université Laval
% 31/01/2011 - version 1.0 - Création du document

\chapter{Description des prototypes}
\label{s:prototypes}
\section{Préhenseur}

Comme dispositif pour le traçage des dessins par le robot, nous opterons pour une solution simple et robuste. Afin d’éviter d’augmenter inutilement la charge de travail du microcontrôleur, nous avons décidé d’éviter d’utiliser des solutions complexes qui pourraient exiger la production d’un signal particulier par le microcontrôleur. Le signal de sortie qui devra être produit sera simplement un signal binaire : « 1» lorsque le crayon devra être en mode traçage et « 0 » lorsque le crayon sera soulevé et donc en mode « attente ». Pour maintenir le crayon en position « attente » durant la durée du trajet, nous utiliserons un système de maintien magnétique qui gardera le crayon en position relevé lorsqu’il recevra le signal « 1 » logique. Pour abaisser le crayon et ainsi entrer en mode traçage, nous utiliserons un ressort à faible constante de rappel qui entrera en jeu lorsque le système de maintien magnétique relâchera le crayon « 0 » logique. Il est bien important que la constante de rappel du ressort soit faible pour ne pas briser la mine lors du contact de celle-ci avec la surface de traçage. La constante de rappel du ressort devra également être inférieure à la force exercée par le système de maintien magnétique qui relèvera le crayon en mode attente, une fois le dessin terminé.

\section{Récepteur et décodeur du signal Manchester}

Pour le récepteur du signal magnétique, nous utiliserons un « tone decoder » qui est utilisé dans de nombreuses applications qui nécessitent la reconnaissance de certaines tonalités bien précises. Comme nous avons besoin de détecter une série de tonalités identiques qui se suivent en formant un code, ce genre de dispositif nous convient parfaitement. Le « tone decoder » recevra le signal par une boucle de fil installée à un endroit sur le robot qui captera la variation du flux magnétique produite par le fil sous la table et détectera si la tonalité inaudible est émise ou non. Lorsque la fréquence (ou tonalité) sera reçue par le récepteur, celui-ci présentera zéro volt en sortie et à l’opposé, lorsque le récepteur ne détectera pas la fréquence ciblée, il présentera 5V à sa sortie. Il exécutera ces opérations d’une façon suffisamment rapide pour que le segment binaire reçu soit exactement le même que celui transmis, mais complètement opposé étant donné la configuration logique du « tone decoder ».  Ce message sera ensuite inversé par l’unité de traitement suivante et traité pour que le robot exécute la tâche adéquate. L’avantage de cette approche est que le « tone decoder » est un circuit intégré très robuste aux perturbations magnétiques de son environnement, il est peu énergivore et très compact.

\section{Microcontrôleur} \label{s:micro}

La composante qui effectuera le lien entre le pont en H qui contrôle les moteurs, les encodeurs sur les moteurs, le signal décodé par le récepteur du signal d'antenne, le préhenseur, la D.E.L., l'écran LCD et le Mac mini sera un microcontrôleur modèle Texas Instrument Stellaris LM3S9B92. Nous avons choisi ce microcontrôleur, car il possède un grand nombre de broches d'entrée/sortie, 4 sorties de signaux PWM, 2 interfaces d'encodeur à quadrature qui permettront le contrôle et l'asservissement des moteurs et il possède également deux ports de communication UART ainsi qu'une interface USB pour la communication avec le Mac mini. De plus, le microcontrôleur est programmé en C à l'aide d'un compilateur, d'un IDE et de librairies de pilotes de périphériques fournies.   

\section{Affichage sur le robot} \label{s:LCD}

Pour afficher les informations nécessaires sur le robot, nous utiliserons un écran à cristaux liquides 16 x 2  caractères. Cet écran est commandé par 8 lignes de données qui permettent de transmettre des caractères ASCII et 3 lignes de contrôle, RS, R/W et E. Le huitième bit de données peut également servir de « busy flag », ce qui permet de savoir si le contrôleur de l'écran a terminé d'exécuter les dernières instructions. En plus de la banque de caractères prédéfinie, il est possible d'ajouter des caractères "maison" dans des espaces libres de la mémoire de caractères. Le contraste peut être contrôlé par un potentiomètre qui fournit la référence sur la broche 3. En ce qui concerne l'alimentation, l'écran peut être alimenté à partir du microcontrôleur, en excluant le rétroéclairage, qui n'est pas nécessaire pour distinguer les caractères dans un environnement éclairé. Si le rétroéclairage devait être utilisé, il serait nécessaire de l'alimenter à l'aide d'une source indépendante du microcontrôleur, car il nécessite 150 mA. Les fonctions codées dans les fichiers ecran.h et ecran.c de l'annexe \ref{s:code_LCD} permettent d'envoyer des caractères et des chaînes de caractères sur le LCD et de contrôler le déplacement du curseur.

\section{Communication entre le microcontrôleur et le Mac mini} \label{s:comm_mac_micro}

Comme le microcontrôleur possède une interface USB qui permet la communication avec l'ordinateur par un port série UART, nous utiliserons ce protocole pour communiquer. Le port UART lève une interruption lorsqu'il reçoit un caractère dans son registre de données. Les données reçues peuvent être enregistrées dans un tampon circulaire durant l'interruption pour être traitées dans le processus principal. Du côté du Mac mini, un terminal série permettra d'envoyer des données par l'interface USB. 

\section{Alimentation du Mac mini} \label{s:alim_mac_mini}
En ce qui a trait au système d'alimentation du Mac mini, le dispositif à concevoir doit réussir à élever la tension de la pile jusqu'à 24V. Cette tension correspond à un point de fonctionnement qui est jugé comme idéal selon les spécifications techniques de l'appareil. On constate par la suite que la puissance demandée par le Mac mini sera la plus grande dépense énergétique du système. Il faut donc envisager une alimentation avec un très bon rendement, de manière à limiter le dimensionnement de la pile. L'usage d'un régulateur de tension conventionnel, qui utilise une tension supérieure à l'alimentation, n'est pas envisageable pour le projet, dans la mesure où le rendement dépasse rarement les 50\%. Ce qui s'offre à la conception de l'alimentation est un système de type «Boost» qui effectue une amplification de la tension continue. Ce type de circuit est le pendant en tension continue du transformateur. En soi, il est possible de réaliser la fonction d'amplification au moyen de composants discrets. Cependant, l'implantation pratique demande beaucoup de temps et de ressources et est généralement moins robuste qu'une alimentation utilisant des composants intégrés. Il est préférable, vu les coûts de l'électronique actuelle, d'opter pour des composants intégrés qui effectuent le même travail avec des rendements très élevés (de l'ordre du 90\% et plus). Aussi, vu le coût de l'ordinateur et sa sensibilité aux oscillations de tension, il est très important de considérer la stabilité de la tension de sortie de l'alimentation. Les régulateurs envisageables pour l'application et les spécifications en courant présentent une ondulation de tension inférieure aux niveaux maximaux du Mac mini ($\pm 200mV$). Il est donc tout indiqué d'opter pour un circuit intégré de type «Boost», vu son bon rendement, sa robustesse, sa facilité d'implantation ainsi que sa stabilité de tension de sortie.

\section{Alimentation de l'électronique embarquée}
En ce qui a trait au système d'alimentation de l'électronique embarquée, l'alimentation de l'électronique autre que le Mac mini doit se faire optimalement en 5V, puisqu'il s'agit d'une tension utilisable pour le servomoteur de la tourelle de la caméra et permet aussi de donner un point de référence au pont en H. Par ailleurs, la plupart des microcontrôleurs ont des entrées 5V, il est donc de mise d'utiliser cette tension pour l'électronique auxiliaire. Le dispositif devra abaisser la tension de la pile à 5V puisque celle-ci sera sélectionnée avec une tension supérieure. On peut tout de suite penser à l'usage d'un régulateur, cependant, pour les mêmes raisons qu'énoncées à la section \ref{s:alim_mac_mini}, un faible rendement de l'alimentation pourrait dégrader la durée de vie de la pile. Vu qu'il est nécessaire d'abaisser la tension, l'utilisation d'une technologie de type «Boost» est impossible. Il existe cependant la technologie de type «Buck», qui produit exactement l'effet contraire. L'utilisation de composés discrets requiert davantage de temps et est moins robuste. Une solution impliquant des composés intégrés doit être envisagée. Par ailleurs, les rendements de ce type d'alimentation peuvent s'élever à plus de 90\%. Les composantes comme le microcontrôleur et le pont en H requièrent une tension d'alimentation stable et l'emploi d'une alimentation faite à partir de composants intégrés permet de convenir à ce besoin. Il est donc tout indiqué d'opter pour un circuit intégré de type «Buck», vu son bon rendement, sa robustesse, sa facilité d'implantation ainsi que sa stabilité de tension de sortie.

\section{Communication sans fil}\label{s:sansfil}
Pour amorcer la communication sans fil entre le robot et la station de base, il faut que cette dernière sache l'adresse IP du robot. Il nous est impossible de brancher un clavier et un écran sur le robot afin de récupérer celle-ci et le réseau sans fil de l'université empêche l'utilisation de service tel que www.NOIP.com pour obtenir de façon dynamique l'IP de la carte réseau. Nous avons donc créé un script «bash» pour récupérer l'adresse IP du robot et l'envoyer à une application en ligne appelée «Pastebin» qui permet d'enregistrer du texte. Le script est placé dans le fichier «/etc/rc.d/rc.local» afin qu'à chaque démarrage, l'adresse IP soit connue. Pour valider l'adresse IP obtenue, il suffit d'essayer de se connecter par «SSH» sur le robot ce qui confirme la possibilité d'utiliser le réseau sans fil pour communiquer avec le robot.

Ultérieurement, nous utiliserons une api en C++ ou en Python pour communiquer.

\section{Lecture des informations d'un sudocube avec la caméra}
Pour réaliser ce prototype, OpenCV fut utilisé ainsi que quelques photos des sudocubes de l’environnement de travail du robot. Le langage de programmation C++ fut employé afin de garantir un temps de traitement relativement faible. Les opérations sur les images exigeant beaucoup de cycles processeur. De plus, l'accès à un plus grand nombre d'exemples de code OpenCV en C++(contrairement au Python) a aussi motivé le choix de ce langage.

L'algorithme testé dans ce prototype commence par effectuer une segmentation par couleur verte sur la photo afin d'isoler le cadre du sudocube. Puis, un algorithme de détection des contours est appliqué. OpenCV retourne, après ces opérations, deux polygones rectangulaires que l'on peut utiliser pour vérifier l'existence du cadre vert dans l'image. On s'assure que le cadre remplit une bonne partie de l'image en calculant l'aire de celui-ci. Cela permet de garantir qu'il y a assez de détails pour lire correctement les cases du sudocube. Ensuite, l'image originale est convertie en tons de gris pour appliquer encore une fois un algorithme de détection des contours. Cela permet de récupérer les polygones de toutes les cases du sudocube. Comme il y a quelques polygones qui ne sont pas des cases, on les élimine en calculant leur aire et en ne gardant que ceux qui sont suffisamment grands.

Afin de garantir la lecture de toutes les cases du sudocube, on pourrait ajouter une détection automatique du seuil de l'algorithme de détection des contours en vérifiant le nombre de polygones trouvés. Il faut en trouver exactement 47.

De plus, pour assurer une bonne lecture des caractères, on pourrait effectuer un réalignement du cadre vert.

Ce qui reste à faire : effectuer une segmentation sur la couleur rouge en mode HSV afin d'identifier la case rouge et créer un algorithme de reconnaissance des caractères pour lire les chiffres dans les cases.

\section{Recherche de chemin}
Afin de résoudre le problème de recherche d'un chemin à parcourir par le robot Kinocto afin d'éviter les obstacles, nous avons dû nous pencher sur certaines contraintes particulières à notre situation. Nous avons tout d'abord décidé de représenter la table à l'aide d'un nuage de points quadrillés, un peu à la manière d'un graphe ayant des coordonnées (x,y). Ce type de représentation facilite beaucoup la recherche de chemin puisque les algorithmes les plus efficaces travaillent sur des graphes. Par la suite, il a fallu considérer que notre robot n'est pas un point ponctuel sur la table. Ce problème a été contourné en insérant une marge autour des obstacles. En ayant des obstacles plus gros, ceci nous permet de garder une représentation du robot comme un point et utiliser un algorithme de recherche de chemin. L'algorithme A* a été choisi, car il est très rapide et facile à implémenter. Finalement, il y a une dernière contrainte à considérer, venant du fait que nous utilisons un nuage de point comme référence sur la table. Il est impossible de se déplacer en diagonale sans "zigzaguer" à travers les obstacles. Ceci engendre beaucoup de rotations nécessaires afin d'arriver au point final ce qui contribue à l'incertitude de la position réelle du robot. Nous ajouterons donc une couche logicielle permettant d'identifier les points critiques du chemin trouvé par l'algorithme A*. Ainsi, cette liste de points permettra au robot de se déplacer en ligne droite lorsqu'il fera des diagonales en ignorant les points inutiles entre les points critiques qui créaient le mouvement involontaire, et réduira par le fait même le nombre de rotations nécessaires avant d'arriver au point final. 

\section{Kinect}
La Kinect est l’outil qui va nous aider à localiser les obstacles et localiser notre robot sur la table. Après l’installation d’OpenNI et OpenCV, nous avons testé la Kinect avec le fichier test.cpp qui permet de faire une capture d’image.\\
Pour localiser le robot par rapport à la Kinect, nous allons le modéliser avec une figure spécifique sur celui-ci (exemple : deux cercles). Ensuite, grâce à la connaissance de la distance entre les deux cercles, nous pourrons déterminer à chaque rafraichissement de position: la distance du robot par rapport à la kinect et par rapport aux obstacles ainsi que sa position angulaire approximative. Pour les équations, nous allons utiliser des équations simples comme les règles de trigonométrie. De plus, afin d'éviter le bruit dans nos images, il est judicieux d'appliquer des filtres correctifs. Le filtre passe-bas est le plus réputé pour enlever le bruit. Toutefois, il rend les images "flou", alors il faut chercher les meilleurs paramètres pour obtenir un filtre optimal et efficace. En ce qui concerne la détection d’obstacles, nous avons deux choix. Le premier choix consiste à faire une capture avec la caméra et en faire l’analyse 2D tandis que le deuxième choix consiste à utiliser l’image de profondeur. Pour le moment, la solution qui semble la plus efficace est l’utilisation de l’image de profondeur qui consiste tout d'abord à isoler l'obstacle qui possède une forme déjà connue et conserver les points dont la profondeur est proche de celle des obstacles. Par la suite, nous conservons une image en teinte de gris, car c'est le contour de l'obstacle qui nous intéresse. Finalement, on se sert d'OpenCV pour définir un détourage de l'obstacle et l'affiner. 
