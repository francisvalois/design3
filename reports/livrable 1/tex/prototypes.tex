%!TEX root = ../rapport.tex
%!TEX encoding = UTF-8 Unicode

% Chapitres "Introduction"

% modifié par Francis Valois, Université Laval
% 31/01/2011 - version 1.0 - Création du document

\chapter{Description des prototypes}
\label{s:prototypes}
\section{Préhenseur}

Comme dispositif pour le traçage des dessins par le robot, nous opterons pour la solution la plus simple et robuste qui soit. Afin d’éviter d’augmenter inutilement la charge de travail du microcontrôleur, nous avons décidé d’éviter d’utiliser des solutions complexes qui pourraient exiger la production d’un signal particulier par le microcontrôleur. Le signal de sortie que devra produire le celui-ci sera simplement un signal binaire : « 1» lorsque le crayon devra être en mode traçage et « 0 » lorsque le crayon sera soulevé et donc en mode « attente ». Pour maintenir le crayon en position « attente » durant la durée du trajet, nous utiliserons un système de maintien magnétique qui gardera le crayon en position relevé lorsqu’il recevra le signal « 1 » logique. Pour abaisser le crayon et ainsi entrer en mode traçage, nous utiliserons un ressort à faible constante de rappel qui entrera en jeu lorsque le système de maintien magnétique relâchera le crayon « 0 » logique. Il est bien important que la constante de rappel du ressort soit faible pour ne pas briser la mine lors du contact de celle-ci avec la surface de traçage. La constante de rappelle du ressort devra également être inférieur à la force exercée par le système de maintien magnétique qui ramènera le crayon en mode attente une fois le dessin terminé.

\section{Récepteur et décodeur du signal manchester}

Pour le récepteur du signal magnétique, nous utiliserons un « tone decoder » qui est utilisé dans de nombreuses applications qui nécessitent la reconnaissance de certaines tonalités bien précises. Comme nous avons besoins de détecter une série tonalités identiques qui se suivent et forme un code, ce genre de dispositif nous convient parfaitement. Le « tone decoder » recevra le signal par une boucle de fil installées à un endroit sur le robot qui captera la variation du flux magnétique produite par le fil sous la table et détectera si la tonalité inaudible est émise ou non. Lorsque la fréquence (ou tonalité) sera reçue par le récepteur, celui-ci présentera zéro volt en sortie et à l’opposé, lorsque le récepteur ne détectera pas la fréquence ciblée, il présentera 5V à sa sortie. Il exécutera ces opérations d’une façon suffisamment rapide pour que le segment binaire reçu soit exactement le même que celui transmis, mais complètement opposé étant donné la configuration logique du « tone decoder ».  Ce message sera ensuite inversé par l’unité de traitement suivante et traité pour que le robot exécute la tâche adéquate. L’avantage de cette approche est que le « tone decoder » est un circuit intégré très robuste aux perturbations magnétiques de son environnement, il est peu énergivore et très compact.

\section{Microcontrôleur} \label{s:micro}

Le lien entre le pont en H contrôlant les moteurs, le signal décodé par le récepteur de signal, le préhenseur et le Mac mini sera un microcontrôleur modèle Texas Instrument Stellaris LM3S9B92. Ce microcontrôleur possèdes un grand nombre de broches d'entrée/sortie, 4 PWM, 2 interfaces d'encodeur à quadrature qui permettront le contrôle et l'asservissement des moteurs Il possède également deux ports de communication UART ainsi qu'une interface USB pour la communication avec le Mac mini. Le microcontrôleur peut être programmé en C avec un compilateur, un IDE et des librairies de pilotes de périphériques fournies.   

\section{Affichage sur le robot} \label{s:LCD}

Pour l'affichage sur le robot, nous utiliserons un écran à cristaux liquides 16 x 2  caractères. Cet écran est commandé par 8 lignes de données qui permettent de transmettre des caractères ASCII et 3 lignes de contrôle, RS, R/W et E. Le huitième bit de données peut également servir de "busy flag", ce qui permet de savoir si le contrôleur de l'écran a terminé d'exécuter les dernières instructions. Il est possible d'ajouter des caractères "maison" dans des espaces libres de la mémoire de caractères. Le contraste peut être contrôlé par un potentiomètre qui fourni la référence sur la broche 3. Il peut être alimenté à même le microcontrôleur, en excluant le rétroéclairage, qui n'est pas nécessaire pour distinguer les caratères dans un environnement éclairé. Si le rétroéclairage devait être utilisé, il devra être alimenté sur une source indépendante du microcontrôleur, car il nécessite 150 mA. Les fonctions codées dans les fichiers ecran.h et ecran.c de l'annexe~\ref{} permettent d'envoyer des caractères et des chaînes de caractères sur le LCD et de contrôler le déplacement du curseur.

\section{Communication entre le microcontrôleur et le Mac mini} \label{s:comm_mac_micro}

Comme le microcontrôleur possède une interface USB qui permet la communication avec l'ordinateur via un port série UART, nous utiliserons le port UART pour la communication. Le port UART lève une interruption lorsqu'il recoit un caractère dans son registre de données. Les données reçues peuvent être enregistrées dans un tampon circulaire durant l'interruption pour être traitées dans le processus principal. Du côté du Mac mini, un terminal série permettra d'envoyer des données via l'interface USB. 

\section{Alimentation du Mac mini} \label{s:alim_mac_mini}
En ce qui a trait au système d'alimentation du Mac mini, le dispostif à concevoir doir réussir à élever la tension de la batterie jusqu'à 24V. Cette tension correspond à un point de fonctionnement qui est jugé comme idéal selon les spécifications techniques de l'appareil. On constate par la suite que la puissance demandée par le Mac mini sera la plus grande dépense énergétique du système. Il faut donc envisager une alimentation avec un très bon rendement, de manière à limiter le dimensionnement de la batterie. L'usage d'un régulateur de tension conventionnel, qui utilise une tension supérieure à l'alimentation, n'est pas envisageable pour le projet, dans la mesure ou le rendement dépasse rarement les 50\%. Ce qui s'offre à la conception de l'alimentation est un système de type «Boost» qui effectue une amplification de la tension continue. Ce type de circuit est le pendant en tension continue du transformateur. En soi, il est possible de réaliser la fonction d'amplification au moyen de composants discrets. Cependant, l'implantation pratique demande beaucoup de temps et de ressources et est généralement moins robuste qu'une alimentation utilisant des composants intégrés. Il est préférable, vu les coûts de l'électronique actuelle, d'opter pour des composants intégrés qui effectuent le même travail avec des rendements très élevés (de l'ordre du 90\% et plus). Aussi, vu le coût de l'ordinateur et sa sensibilité aux oscillations de tension, il est très important de considérer la stabilité de la tension de sortie de l'alimentation. Les régulateurs envisageables pour l'application et les spécifications en courant présentent une ondulation de tension inférieure aux niveaux maximaux du Mac mini ($\pm 200mV$). Il est donc tout indiqué d'opter pour un circuit intégré de type «Boost», vu son bon rendement, sa robustesse, sa facilité d'implantation ainsi que sa stabilité de tension de sortie.

\section{Alimentation de l'électronique embarquée}
En ce qui a trait au système d'alimentation de l'électronique embarquée, l'alimentation de l'électronique autre que le Mac mini doit se faire optimalement en 5V, puisqu'il s'agit d'une tension utilisable pour le servomoteur de la tourelle de caméra et permet aussi de donner un point de référence au pont en H. Par ailleurs, la plupart des microcontrôleurs ont des entrées 5V, il est donc de mise d'utiliser cette tension pour l'électronique auxiliaire. Le dispositif devra abaisser la tension de la batterie à 5V puisque celle-ci sera sélectionnée avec une tension supérieure. On peut tout de suite songer à l'usage d'un régulateur, cependant, pour les mêmes raisons qu'énoncées à la section \ref{s:alim_mac_mini}, un faible rendement de l'alimentation pourrait dégrader la durée de vie de la batterie. Vu qu'il est nécessaire d'abaisser la tension, l'utilisation d'une technologie de type «Boost» est impossible. Il existe cependant la technologie de type «Buck», qui produit exactement l'effet contraire. L'utilisation de composés discrets requiert davantage de temps et est moins robuste. Une solution impliquant des composés intégrés doit être envisagée. Par ailleurs, les rendements de ce type d'alimentation peuvent s'élever à plus de 90\%. Les composantes comme le microcontrôleur et le pont en H requièrent une tension d'alimentation stable et l'emploi d'une alimentation faite à partir de composants intégrés permet de convenir à ce besoin. Il est donc tout indiqué d'opter pour un circuit intégré de type «Buck», vu son bon rendement, sa robustesse, sa facilité d'implantation ainsi que sa stabilité de tension de sortie.

\section{Communication sans fil}\label{s:sansfil}
Pour initier la communication sans-fil entre le robot et la station de base, il faut que cette dernière connaisse l'adresse ip du robot. Il nous est impossible de brancher un clavier et un écran sur le robot afin de récupérer celle-ci et le réseau sans fil de l'université empêche l'utilisation de service tel que www.NOIP.com pour obtenir un DNS. Nous avons donc créer un script bash pour récupérer l'adresse ip du robot et l'envoyer à une application en ligne appelée pastebin qui permet d'enregistrer du texte. Le script est placé dans le fichier /etc/rc.d/rc.local afin qu'à chaque démarrage l'adresse ip soit connue. Nous avons validé l'adresse ip obtenue en l'utilisant pour se connecter par ssh sur le robot. Confirmant ainsi la possibilité d'utiliser le réseau sans-fil pour communiquez avec le robot.

Ultérieurement nous utiliserons une api en c++ ou en python pour communiquer.

\section{Calcul et affichage de la trajectoire}\label{s:traj}
Afin de trouver une trajectoire correcte, rapide et qui évite tous les obstacles, il faut trouver le chemin le plus court entre deux nœuds et évaluer si un chemin existe entre ces deux derniers.  Pour atteindre ces objectifs, on va utiliser le path-planning  avec l’algorithme A* qui est simple et répond à tous nos besoins.\\
Pour l’affichage de la trajectoire en temps réel, le robot transmet sa position(x,y) sous forme de message à la station de base (au minimum toutes les  15 secondes entre chaque position) en utilisant la connexion Wifi.

\section{Lecture des informations d'un sudocube avec la caméra}
Pour réaliser ce prototype, OpenCV fut utilisé ainsi que quelques photos des sudocubes de l’environnement de travail du robot. Le langage de programmation C++ fut employé afin de garantir un temps de traitement relativement faible. Les opérations sur les images exigeant beaucoup de cycles processeur. De plus, l'accès à un plus grand nombre d'exemples de code OpenCV en C++(versus en python) a aussi motivé le choix de ce langage.

L'algorithme testé dans ce prototype commence par effectuer une segmentation par couleur verte sur la photo afin d'isoler le cadre du sudocube. Puis, un algorithme de détection des contours est appliqué. OpenCV retourne après cette opération deux polygones rectangulaires que l'on peut utiliser pour vérifier l'existence du cadre vert dans l'image. On s'assure que le cadre remplit une bonne partie de l'image en calculant l'aire de celui-ci. Cela permet de garantir qu'il y a assez de détails pour lire correctement les cases du sudocube. Puis, l'image originale est convertie en tons de gris pour appliquer encore une fois un algorithme de détection des contours. Cela permet de récupérer les polygones de toutes les cases du sudocube. Il y a quelques polygones qui ne sont pas des cases. On les élimine en calculant leur aire et en ne gardant que ceux qui sont suffisamment grands.

Afin de garantir la lecture de toutes les cases du sudocube, on pourrait ajouter une détection automatique du “threshold” de l'algorithme de détection des contours en vérifiant le nombre de polygones trouvés. Il faut en trouver 47 très exactement.

Pour assurer une bonne lecture des caractères, on pourrait effectuer un réalignement du cadre vert.

Ce qui reste à faire : effectuer une segmentation sur la couleur rouge en mode HSV afin d'identifier la case rouge et créer un algorithme d'OCR pour lire les chiffres dans les cases.

\section{Recherche de chemin}
Afin de résoudre le problème de recherche d'un chemin à parcourir par kinocto afin d'éviter les obstacle, nous avons dû nous pencher sur certaines contraintes particulières à notre situation. Nous avons tout d'abord décidé de représenter la table à l'aide d'un nuage de points quadrillés, un peu à la manière d'un graphe ayant des coordonnées (x,y). Ce type de représentation facilite beaucoup la recherche de chemin puisque les algorithmes permettant la recherche de chemin le plus efficace travaillent sur des graphes.  Par la suite, il a fallu considérer que notre robot n'est pas un point ponctuel sur la table. Ce problème a été contourné en insérant une marge autour des obstacles. En ayant des obstacles plus gros, ceci nous permet de garder une représentation du robot comme un point et utiliser un algorithme de recherche de chemin tel quel. Quant à l'algorithme, nous avons choisi A*. Inutile de justifier ce choix, cet algorithme est prouvé être l'un des plus rapides et est aussi facile à implémenter. Finalement, il y a une dernière contrainte à considérer, venant du fait que nous utilisons un nuage de point comme référence sur la table. Il est impossible de se déplacer en diagonale sans "zigzaguer" à travers les obstacles. Ceci engendre beaucoup de rotation nécessaires afin d'arriver au point final et donc contribue à l'incertitude de la position réelle du robot. Nous ajouterons donc une couche logicielle permettant d'identifier les points critiques du chemin trouvé par l'algorithme A*. Ainsi, cette liste réduite de points permettra au robot de se déplacer en ligne droite lorsqu'il fera des diagonales en ignorant les points inutiles entre les points critiques qui créaient le mouvement zigzag, et réduira par le fait même le nombre de rotations nécessaires avant d'arriver au point final. 

\section{Kinect}
La kinect est l’outil qui va nous aider à localiser les obstacles et localiser notre robot sous différents angles. Après l’installation d’OpenNi et OpenCv, on a testé la kinect avec le fichier test.cpp qui permet de faire une capture d’image.\\
Pour localiser le robot par rapport à la kinect, on va le modéliser avec une figure (exemple : deux cercles), ensuite  grâce à la connaissance de la distance entre les deux cercles, on pourra déterminer à chaque rafraichissement de position, la distance du robot par rapport à la kinect, par rapport aux obstacles et de déterminer sa position angulaire. Pour  les équations, on va utiliser des équations simples comme les règles de trigonométrie. Afin d'éviter le bruit dans nos images on va appliquer des filtres. Le filtre passe bas est le plus réputé  pour enlever du bruit par contre il rend les images "flou", alors il faut chercher les meilleurs paramètres pour avoir un filtre optimal et efficace.  Pour la détection d’obstacles, on a deux choix soit faire une capture avec la caméra ensuite faire l’analyse 2D, soit utiliser l’image de profondeur. Pour le moment la solution qui semble efficace c’est l’utilisation de l’image de profondeur.
